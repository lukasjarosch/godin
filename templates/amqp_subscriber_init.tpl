// Code generated by Godin {{ .Godin.Version }}; DO NOT EDIT.
package amqp

import (
	"github.com/pkg/errors"

	"github.com/go-godin/log"
	middleware "github.com/go-godin/middleware/amqp"
	"github.com/go-godin/rabbitmq"

    "{{ .Service.Module }}/internal/service"
    "{{ .Service.Module }}/internal/service/subscriber"
)

type SubscriberSet struct {
    {{- range .Service.Subscriber }}
    {{ untitle .Handler }} rabbitmq.Subscriber
	{{- end }}
}

// Subscriptions will initialize all AMQP subscriptions. For each subscription, a new AMQP channel is created on which
// the Consume() goroutine will run (one channel per thread policy).
func Subscriptions(conn *rabbitmq.RabbitMQ) SubscriberSet {
	{{- range .Service.Subscriber }}
	{{ untitle .Handler }}Channel, _ := conn.NewChannel()
	{{- end }}

	return SubscriberSet{
    {{- range .Service.Subscriber }}
        {{ untitle .Handler }}: rabbitmq.NewSubscriber({{ untitle .Handler }}Channel, &rabbitmq.Subscription{
            Exchange: "{{ .Subscription.Exchange }}",
		    Topic: "{{ .Subscription.Topic }}",
            AutoAck:  {{ .Subscription.AutoAck }},
            Queue: rabbitmq.SubscriptionQueue{
                AutoDelete: {{ .Subscription.Queue.AutoDelete }},
                Durable:    {{ .Subscription.Queue.Durable }},
                Exclusive:  {{ .Subscription.Queue.Exclusive }},
                Name:       "{{ .Subscription.Queue.Name }}",
                NoWait:     {{ .Subscription.Queue.NoWait }},
            },
		}),
	{{ end }}
	}
}

{{- $serviceName := title .Service.Name -}}

{{- range .Service.Subscriber }}
// {{ .Handler }} sets up the subscription to the '{{ .Subscription.Topic }}' topic. All middleware is automatically registered
// and called in the following order: RequestID => PrometheusInstrumentation => Logging => subscriber.{{ .Handler }}
// The RequestID middlware will extract the requestId from the delivery header or generate a new one. The requestId is
// then mad available through the context.
func (ss SubscriberSet) {{ .Handler }}(logger log.Logger, usecase service.{{ $serviceName }}) error {
	handler := subscriber.{{ .Handler }}Subscriber(logger, usecase, {{ .Handler }}Decoder)
	handler = middleware.Logging(logger, "{{ .Subscription.Topic }}", handler)
	handler = middleware.PrometheusInstrumentation("{{ .Subscription.Topic }}", handler)
	handler = middleware.RequestID(handler)

	if err := ss.{{ untitle .Handler }}.Subscribe(handler); err != nil {
		logger.Error("failed to subscribe to {{ .Subscription.Topic }}", "err", err, "transport", "AMQP")
		return errors.Wrap(err, "failed to subscribe to {{ .Subscription.Topic }}")
	}
	logger.Info(
		"subscribed to topic '{{ .Subscription.Topic }}'",
		"topic", ss.{{ untitle .Handler }}.Subscription.Topic,
		"queue", ss.{{ untitle .Handler }}.Subscription.Queue.Name,
		"exchange", ss.{{ untitle .Handler }}.Subscription.Exchange,
		"transport", "AMQP",
	)

	return nil
}
{{ end }}

// Shutdown will call Shutdown() on all registered subscriptions
func (ss SubscriberSet) Shutdown() (err error) {
	{{- range .Service.Subscriber }}
	err = ss.{{ untitle .Handler }}.Shutdown()
	{{- end }}

	return err
}
